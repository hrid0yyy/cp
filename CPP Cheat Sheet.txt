							C + +

// VECTOR
// Use case: Dynamic array, fast random access, frequent insert/remove at end.
vector<int> v = {1,2,3};           // Declare and initialize
v.push_back(4);                    // Add 4 at end
v.pop_back();                      // Remove last element
v.size();                          // Number of elements
v.empty();                         // True if vector is empty
v.clear();                         // Remove all elements
v[0];                              // Access first element
v.front();                         // Get first element
v.back();                          // Get last element
sort(v.begin(), v.end());          // Sort elements in ascending order

// MAP
// Use case: Key-value pairs, sorted by key, fast search/insert/delete by key.
map<int, int> m;                   // Declare empty map
m[1] = 2;                          // Insert/update key 1 with value 2
m.insert({3,4});                   // Insert key 3 with value 4
m.erase(1);                        // Remove key 1
m.size();                          // Number of key-value pairs
m.empty();                         // True if map is empty
m.clear();                         // Remove all pairs
m.find(3);                         // Iterator to key 3 (or end if not found)
m.count(3);                        // 1 if key 3 exists, else 0
for(auto& p : m) cout<<p.first<<":"<<p.second<<" "; // Iterate all pairs

// UNORDERED_MAP
// Use case: Key-value pairs, not sorted, faster average search/insert/delete.
unordered_map<int, int> um;        // Declare empty unordered_map
um[1] = 2;                         // Insert/update key 1 with value 2
um.insert({3,4});                  // Insert key 3 with value 4
um.erase(1);                       // Remove key 1
um.size();                         // Number of key-value pairs
um.empty();                        // True if map is empty
um.clear();                        // Remove all pairs
um.find(3);                        // Iterator to key 3 (or end if not found)
um.count(3);                       // 1 if key 3 exists, else 0
for(auto& p : um) cout<<p.first<<":"<<p.second<<" "; // Iterate all pairs

// LIST (Doubly Linked List)
// Use case: Frequent insert/remove at both ends or in middle, no random access.
list<int> l = {1,2,3};             // Declare and initialize
l.push_back(4);                    // Add 4 at end
l.push_front(0);                   // Add 0 at front
l.pop_back();                      // Remove last element
l.pop_front();                     // Remove first element
l.size();                          // Number of elements
l.empty();                         // True if list is empty
l.clear();                         // Remove all elements
l.front();                         // Get first element
l.back();                          // Get last element
l.reverse();                       // Reverse the list
for(int x : l) cout<<x<<" ";       // Iterate all elements

// DEQUE
// Use case: Fast insert/remove at both ends, random access.
deque<int> dq = {1,2,3};           // Declare and initialize
dq.push_back(4);                   // Add 4 at end
dq.push_front(0);                  // Add 0 at front
dq.pop_back();                     // Remove last element
dq.pop_front();                    // Remove first element
dq.size();                         // Number of elements
dq.empty();                        // True if deque is empty
dq.clear();                        // Remove all elements
dq.front();                        // Get first element
dq.back();                         // Get last element
for(int x : dq) cout<<x<<" ";      // Iterate all elements

// STACK
// Use case: LIFO (last-in, first-out), undo operations, recursion simulation.
stack<int> s;                      // Declare empty stack
s.push(1);                         // Push 1 onto stack
s.pop();                           // Remove top element
s.top();                           // Access top element
s.size();                          // Number of elements
s.empty();                         // True if stack is empty

// QUEUE
// Use case: FIFO (first-in, first-out), task scheduling, BFS.
queue<int> q;                      // Declare empty queue
q.push(1);                         // Add 1 to back
q.pop();                           // Remove front element
q.front();                         // Access front element
q.back();                          // Access back element
q.size();                          // Number of elements
q.empty();                         // True if queue is empty

// PRIORITY QUEUE (Max Heap)
// Use case: Always access largest element, scheduling, greedy algorithms.
priority_queue<int> pq;            // Declare empty max-heap
pq.push(3);                        // Add 3
pq.push(1);                        // Add 1
pq.top();                          // Access largest element
pq.pop();                          // Remove largest element
pq.size();                         // Number of elements
pq.empty();                        // True if empty

// PRIORITY QUEUE (Min Heap)
// Use case: Always access smallest element, scheduling, greedy algorithms.
priority_queue<int, vector<int>, greater<int>> pqmin; // Declare min-heap
pqmin.push(3);                      // Add 3
pqmin.push(1);                      // Add 1
pqmin.top();                        // Access smallest element
pqmin.pop();                        // Remove smallest element
pqmin.size();                       // Number of elements
pqmin.empty();                      // True if empty

// <algorithm> - Useful Algorithms
sort(v.begin(), v.end());                  // Sort ascending
sort(v.begin(), v.end(), greater<int>());  // Sort descending
reverse(v.begin(), v.end());               // Reverse elements
next_permutation(v.begin(), v.end());      // Next lexicographical permutation
prev_permutation(v.begin(), v.end());      // Previous lexicographical permutation
rotate(v.begin(), v.begin()+k, v.end());   // Rotate left by k
unique(v.begin(), v.end());                // Remove consecutive duplicates
count(v.begin(), v.end(), x);              // Count occurrences of x
find(v.begin(), v.end(), x);               // Find x, returns iterator
binary_search(v.begin(), v.end(), x);      // True if x exists (sorted)
lower_bound(v.begin(), v.end(), x);        // Iterator to first >= x (sorted)
upper_bound(v.begin(), v.end(), x);        // Iterator to first > x (sorted)
max_element(v.begin(), v.end());           // Iterator to max element
min_element(v.begin(), v.end());           // Iterator to min element
accumulate(v.begin(), v.end(), 0);         // Sum of elements
fill(v.begin(), v.end(), x);               // Fill with x
copy(v.begin(), v.end(), v2.begin());      // Copy v to v2
swap(a, b);                                // Swap a and b

// <numeric>
accumulate(v.begin(), v.end(), 0);         // Sum of elements
iota(v.begin(), v.end(), 0);               // Fill with 0,1,2,...

// <cmath> - Math Functions
abs(x);                                    // Absolute value
pow(a, b);                                 // a^b
sqrt(x);                                   // Square root
ceil(x);                                   // Ceiling
floor(x);                                  // Floor
round(x);                                  // Round to nearest integer
log(x);                                    // Natural log
log2(x);                                   // Base-2 log
log10(x);                                  // Base-10 log
sin(x), cos(x), tan(x);                    // Trigonometric functions

// <string> - String Functions
string s = "abc";
s.size();                                  // Length
s.empty();                                 // True if empty
s.clear();                                 // Remove all chars
s.substr(pos, len);                        // Substring
s.find("bc");                              // Find substring
s.replace(pos, len, "xyz");                // Replace substring
s.erase(pos, len);                         // Erase substring
s.insert(pos, "xyz");                      // Insert substring
reverse(s.begin(), s.end());               // Reverse string
stoi(s);                                   // String to int
to_string(x);                              // Int to string

// <bitset> - Bit Manipulation
bitset<8> b("10101010");                   // Declare bitset
b.count();                                 // Number of set bits
b.any();                                   // Any bit set?
b.none();                                  // No bits set?
b.set();                                   // Set all bits
b.reset();                                 // Reset all bits
b.flip();                                  // Flip all bits
b.to_ulong();                              // Convert to unsigned long

// <utility> - Pair
pair<int, int> p = {1,2};                  // Declare pair
p.first;                                   // Access first
p.second;                                  // Access second
make_pair(a, b);                           // Create pair

// <tuple> - Tuple
tuple<int, int, string> t = {1,2,"abc"};   // Declare tuple
get<0>(t);                                 // Access first element
get<1>(t);                                 // Access second element

// <set> - Set
set<int> st;                               // Declare set
st.insert(1);                              // Insert
st.erase(1);                               // Remove
st.count(1);                               // Exists?
st.find(1);                                // Iterator to 1
st.size();                                 // Number of elements
st.empty();                                // True if empty
st.clear();                                // Remove all
st.lower_bound(x);                         // Iterator to first >= x
st.upper_bound(x);                         // Iterator to first > x

// <unordered_set> - Unordered Set
unordered_set<int> ust;                    // Declare unordered set
ust.insert(1);                             // Insert
ust.erase(1);                              // Remove
ust.count(1);                              // Exists?
ust.find(1);                               // Iterator to 1
ust.size();                                // Number of elements
ust.empty();                               // True if empty
ust.clear();                               // Remove all

// <map> and <unordered_map> - See previous cheat sheets

// <queue>, <stack>, <deque>, <priority_queue> - See previous cheat sheets

// <chrono> - Timing
auto start = chrono::high_resolution_clock::now(); // Start timer
auto end = chrono::high_resolution_clock::now();   // End timer
chrono::duration<double> diff = end - start;       // Time difference
cout << diff.count() << " s\n";                    // Print seconds

// <random> - Random Numbers
mt19937 rng(time(0));                              // Random generator
uniform_int_distribution<int> dist(1, 100);        // Range [1,100]
int x = dist(rng);                                 // Get random int

// <functional> - Lambda Functions
auto cmp = [](int a, int b){ return a > b; };      // Comparator
sort(v.begin(), v.end(), cmp);                     // Custom sort

// <limits> - Limits
int inf = numeric_limits<int>::max();              // Maximum int


						
